import { BehaviorSubject, Subject } from 'rxjs';
import { tap, map, filter } from 'rxjs/operators';
import { IsGuid } from './IsGuid';
import { action } from './store.enum';
/**
 * Creates and Odata service store that follows the observable store pattern.
 * Provides default odata rest methods
 */
var ODataStore = /** @class */ (function () {
    function ODataStore(http, settings) {
        var _this = this;
        if (settings === void 0) { settings = null; }
        this.http = http;
        this.settings = settings;
        this._initState = { "@odata.count": undefined, value: [{}] };
        this._state$ = new BehaviorSubject(undefined);
        this.state$ = this._state$.asObservable().pipe(filter(function (f) { return typeof f === "object"; })); /* only get objects not the default state */
        this._notifier$ = new Subject();
        this.notifier$ = this._notifier$.asObservable();
        this._response$ = new Subject();
        this.response$ = this._response$.asObservable();
        this._settings = {
            //defaults
            notifyOnDelete: true,
            notifyOnGet: false,
            notifyOnInsert: true,
            notifyOnUpdate: true
        };
        this.query = function (queryString) {
            if (queryString === void 0) { queryString = null; }
            var segments = [];
            if (queryString) {
                segments.push.apply(segments, queryString.split('&'));
            }
            segments.push("$count=true");
            var query = segments.join('&'); //; state ? `${toODataString(state)}&$count=true` : "";
            _this.http.get(_this.baseUrl + "?" + query, { observe: "response" })
                .subscribe(function (s) {
                _this._response$.next(s);
                var currentState = Object.assign({}, _this._state$.getValue(), _this._initState);
                currentState["@odata.count"] = s.body["@odata.count"];
                currentState.value = s.body.value;
                _this.fillStore(currentState);
                _this.dispatchNotifier(action.Query);
            });
        };
        this.get = function (value, keys, queryString) {
            if (keys === void 0) { keys = null; }
            if (queryString === void 0) { queryString = null; }
            var segments = [];
            if (queryString) {
                segments.push.apply(segments, queryString.split('&'));
            }
            var query = segments.join('&');
            var id;
            if (Array.isArray(keys)) {
                id = keys.map(function (m) { return m + "=" + _this.quoteKey(value[m]); }).join();
            }
            else {
                id = _this.quoteKey(value[keys]);
            }
            var getObs = _this.http.get(_this.baseUrl + "(" + id + ")?" + query, { observe: "response" }).pipe(tap(function (t) { _this._response$.next(t); _this.dispatchNotifier(action.Get); }), map(function (m) { return m.body; }));
            return getObs;
        };
        this.insert = function (item, queryString) {
            if (queryString === void 0) { queryString = null; }
            var segments = [];
            if (queryString) {
                segments.push.apply(segments, queryString.split('&'));
            }
            var query = segments.join('&');
            _this.http.post(_this.baseUrl + "?" + query, item, { observe: "response" }).subscribe(function (s) {
                _this._response$.next(s);
                _this.updateStore(s.body, "insert");
            });
        };
        this.update = function (item, keys, queryString, method) {
            if (keys === void 0) { keys = null; }
            if (queryString === void 0) { queryString = null; }
            if (method === void 0) { method = "put"; }
            var segments = [];
            if (queryString) {
                segments.push.apply(segments, queryString.split('&'));
            }
            var query = segments.join('&');
            var id;
            if (Array.isArray(keys)) {
                id = keys.map(function (m) { return m + "=" + _this.quoteKey(item[m]); }).join();
            }
            else {
                id = _this.quoteKey(item[keys]);
            }
            var url = keys != null ? _this.baseUrl + "(" + id + ")?" + query : _this.baseUrl + "?" + query;
            var operation;
            switch (method) {
                case "post":
                    operation = _this.http.post(url, item, { observe: "response" });
                    break;
                default:
                    operation = _this.http.put(url, item, { observe: "response" });
                    break;
            }
            operation.subscribe(function (s) {
                _this._response$.next(s);
                _this.updateStore(item, "update", keys);
            });
        };
        this.patch = function (item, keys, queryString, method) {
            if (keys === void 0) { keys = null; }
            if (queryString === void 0) { queryString = null; }
            if (method === void 0) { method = "patch"; }
            var segments = [];
            if (queryString) {
                segments.push.apply(segments, queryString.split('&'));
            }
            var query = segments.join('&');
            var id;
            if (Array.isArray(keys)) {
                id = keys.map(function (m) { return m + "=" + _this.quoteKey(item[m]); }).join();
            }
            else {
                id = _this.quoteKey(item[keys]);
            }
            var url = keys != null ? _this.baseUrl + "(" + id + ")?" + query : _this.baseUrl + "?" + query;
            var operation;
            switch (method) {
                case "put":
                    operation = _this.http.put(url, item, { observe: "response" });
                    break;
                case "post":
                    operation = _this.http.post(url, item, { observe: "response" });
                    break;
                default:
                    operation = _this.http.patch(url, item, { observe: "response" });
                    break;
            }
            //this.http.patch(url, item, { observe: "response" })
            operation.subscribe(function (s) {
                _this._response$.next(s);
                _this.updateStore(item, "update", keys);
            });
        };
        this.remove = function (item, keys, method) {
            if (keys === void 0) { keys = null; }
            if (method === void 0) { method = "delete"; }
            var id;
            if (Array.isArray(keys)) {
                id = keys.map(function (m) { return m + "=" + _this.quoteKey(item[m]); }).join();
            }
            else {
                id = _this.quoteKey(item[keys]);
            }
            var url = keys != null ? _this.baseUrl + "(" + id + ")" : "" + _this.baseUrl;
            var operation = method == "delete" ? _this.http.delete(url, { observe: "response" }) : _this.http.post(url, item, { observe: "response" });
            operation.subscribe(function (s) {
                _this._response$.next(s);
                _this.updateStore(item, "delete", keys);
            });
        };
        this.updateStore = function (item, operation, keys) {
            if (keys === void 0) { keys = null; }
            var _store = Object.assign({}, _this._initState, _this._state$.getValue());
            var newState;
            var values;
            switch (operation) {
                case "insert":
                    values = [item].concat(_store.value);
                    newState = { "@odata.count": _store["@odata.count"] + 1, value: values };
                    _this.fillStore(newState);
                    _this.dispatchNotifier(action.Insert, item);
                    break;
                case "delete":
                    var id = void 0;
                    if (Array.isArray(keys)) {
                        //use reduce to find items to remove
                        var removed_1 = keys.reduce(function (acc, curr) {
                            acc = acc.filter(function (f) { return f[curr] == item[curr]; });
                            return acc;
                        }, _store.value);
                        //then filter from original array
                        values = _store.value.filter(function (f) { return removed_1.indexOf(f); });
                    }
                    else {
                        values = _store.value.filter(function (f) { return f[keys] != item[keys]; });
                    }
                    newState = { "@odata.count": values.length, value: values };
                    _this.fillStore(newState);
                    _this.dispatchNotifier(action.Delete, item);
                    break;
                case "update":
                    var res = Object.assign({}, _this._initState, _this._state$.getValue());
                    var foundIdx = void 0;
                    if (Array.isArray(keys)) {
                        values = keys.reduce(function (acc, curr) {
                            acc = acc.filter(function (f) { return f[curr] == item[curr]; });
                            return acc;
                        }, _store.value);
                        foundIdx = res.value.findIndex(function (f) { return f == values[0]; });
                    }
                    else {
                        foundIdx = res.value.findIndex(function (f) { return f[keys] == item[keys]; });
                    }
                    var updated = Object.assign({}, res.value[foundIdx], item);
                    values = res.value.slice(0, foundIdx).concat([updated], res.value.slice(foundIdx + 1));
                    newState = { "@odata.count": res["@odata.count"], value: values };
                    _this.fillStore(newState);
                    _this.dispatchNotifier(action.Update, item);
                    break;
                default:
                    throw "Invalid data store operation";
            }
        };
        this.fillStore = function (odata) {
            _this._state$.next(odata);
        };
        this.dispatchNotifier = function (act, state) {
            if (state === void 0) { state = null; }
            var settings = _this._settings;
            var note = { action: act, state: state };
            var store = _this._state$.getValue();
            switch (act) {
                case action.Query:
                    note.message = "Query returned " + (store ? store.value ? store.value.length : 0 : 0) + " records.";
                    break;
                case action.Get:
                    note.message = "Get action completed";
                    break;
                case action.Delete:
                    note.message = "Record deleted";
                    break;
                case action.Insert:
                    note.message = "New record inserted";
                    break;
                case action.Update:
                    note.message = "Record updated";
                    break;
                default:
                    break;
            }
            if (settings.notifyOnDelete && act == action.Delete
                || settings.notifyOnGet && act == action.Get
                || settings.notifyOnInsert && act == action.Insert
                || settings.notifyOnUpdate && act == action.Update) {
                _this._notifier$.next(note);
            }
        };
        this.quoteKey = function (id) {
            var quotes = "";
            if (typeof id === "string" && !IsGuid(id)) {
                quotes = "'";
            }
            return "" + quotes + id + quotes;
        };
        if (settings) {
            this._settings = Object.assign({}, this._settings, settings);
        }
    }
    return ODataStore;
}());
export { ODataStore };
//# sourceMappingURL=odata.store.js.map